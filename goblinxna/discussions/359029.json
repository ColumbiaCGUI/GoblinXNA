[
  {
    "Id": "847038",
    "ThreadId": "359029",
    "Html": "\r\n<p>Hello,</p>\r\n<p>Currently, I am creating a simple application that projects different objects above different markers and users can read the data registered on GeometryNode's userdata using mouse.</p>\r\n<p>Previously, I have successfully do the picking objects thing by following the tutorial shown on Tutorial 8 on single marker with multiple objects and successfully recognize the userdata registered on each geometry objects.</p>\r\n<p>but the problem came when I separate each objects to different&nbsp;markers . The assigned 3D objects on the marker is shown on the screen and I can see the userdata too but somehow it still picked objects and userdata on different markers! (and the weird\r\n thing is my mouse is pointing at a space where there is no objects on it!)</p>\r\n<p>Firstly, I assumed that this was a problem in ray picking algorithm, so I changed it to use only the marker that is detected by camera but it still detects the object on different markers&nbsp;</p>\r\n<p>here is the part of code I use to do ray picking</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre> <span style=\"color:blue\">foreach</span> (MarkerNode marker <span style=\"color:blue\">in</span> registeredMarkers)\n\t{\n\t\t<span style=\"color:blue\">if</span> (marker.MarkerFound)\n\t\t{\n\t\t\t\tVector3 nearSource = <span style=\"color:blue\">new</span> Vector3(mouseLocation.X, mouseLocation.Y, 0);\n\t\t\t\tVector3 farSource = <span style=\"color:blue\">new</span> Vector3(mouseLocation.X, mouseLocation.Y, 1);\n<br></pre>\r\n<span style=\"color:green\"><span style=\"white-space:pre\">&nbsp;</span>// ray pick on each marker's view matrix</span><span style=\"white-space:pre; background-color:white\">\r\n</span>\r\n<pre>\t\t\t\tMatrix viewMatrix = marker.WorldTransformation * State.ViewMatrix;\n\t\t\t\t\n\t\t\t\tVector3 nearPoint = SimpleApp.GraphicsDevice.Viewport.Unproject(nearSource,\n\t\t\t\t\t\tState.ProjectionMatrix, viewMatrix, Matrix.Identity);\n\t\t\t\tVector3 farPoint = SimpleApp.GraphicsDevice.Viewport.Unproject(farSource,\n\t\t\t\t\t\tState.ProjectionMatrix, viewMatrix, Matrix.Identity);\n\n\t\t\t\tList&lt;PickedObject&gt; pickedObjects = ((NewtonPhysics)SimpleApp.MainScene.PhysicsEngine).PickRayCast(\n\t\t\t\t\t\tnearPoint, farPoint);\n\t\t\t\n\t\t\t<span style=\"color:green\">// etc</span>\n\t\t\t<span style=\"color:green\">// etc</span>\n\t\t\t\n\t\t}\n\t}\n</pre>\r\n</div>\r\n<p>Did I just do something wrong? If so please tell me where I made a mistake so that I can change the code.&nbsp;</p>\r\n<p>and my scene graph is pretty simple too something like this :</p>\r\n<p>before separating :</p>\r\n<p>RootNode -&gt; MarkerNode -&gt; TransformNode -&gt; GeometryNode</p>\r\n<p style=\"padding-left:150px\"><span>&nbsp; &nbsp;-&gt; TransformNode -&gt; GeometryNode</span></p>\r\n<p style=\"padding-left:150px\"><span>&nbsp; &nbsp;-&gt; TransformNode -&gt; GeometryNode</span></p>\r\n<p style=\"padding-left:150px\"><span><span><span>&nbsp; &nbsp;</span><span style=\"white-space:pre\">-</span></span>&gt;</span>&nbsp;etc...</p>\r\n<p>after separating :</p>\r\n<p>RootNode -&gt; MarkerNode -&gt; TransformNode -&gt; GeometryNode</p>\r\n<p style=\"padding-left:60px\"><span style=\"white-space:pre\">-&gt; MarkerNode -&gt; TransformNode -&gt; GeometryNode</span></p>\r\n<p style=\"padding-left:60px\"><span style=\"white-space:pre\"><span style=\"white-space:pre\">-&gt; MarkerNode -&gt; TransformNode -&gt; GeometryNode</span></span></p>\r\n<p style=\"padding-left:60px\"><span style=\"white-space:pre\"><span style=\"white-space:pre\">-</span>&gt;</span>&nbsp;etc...</p>\r\n<p>any Idea?</p>\r\n",
    "PostedDate": "2012-06-10T01:36:44.52-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "847045",
    "ThreadId": "359029",
    "Html": "<p>Please read this post:&nbsp;<a href=\"http://goblinxna.codeplex.com/discussions/207594\">http://goblinxna.codeplex.com/discussions/207594</a></p>",
    "PostedDate": "2012-06-10T02:14:57.17-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "847098",
    "ThreadId": "359029",
    "Html": "<p>Thank you for your fast reply ,</p>\r\n<p>I've read the post from the link you have provided and am i correct whenever the camera detects a marker, a whole physics objects in physics engine will be mapped on that marker even though there are 3d objects that are not present (objects that attached to another marker but registered in physics engine) ? so if the camera detects more than one marker, every marker has the same physics objects? please correct me if I am wrong.&nbsp;</p>\r\n<p>I also have tried to unregister the physics (set addToPhysicsEngine to false ) from physics engine when the marker is not detected and register it when marker is detected. its working right when the camera captures single marker, but not when capturing multiple marker.</p>\r\n<p>Actually what I may need is know how to ray picking on different markers, these past five hours, I tried to do the triangle picking but still stuck</p>\r\n<p>any other solution that I can try?</p>\r\n<p>&nbsp;</p>\r\n<p>Thank you for this great work of Goblin XNA :) &nbsp;</p>",
    "PostedDate": "2012-06-10T07:42:17.15-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "847272",
    "ThreadId": "359029",
    "Html": "<p>Physics in AR is quite tricky. It's currently designed to work well with physics simulation in AR rather than simple picking, so you will need to work around a bit to make the picking happen correctly. If you see Tutorial 8 that for simple collision detection, you need to manually \"transport\" the object in the physics engine by using the NewtonPhysics.SetTransform method. Change of marker transformation won't affect the transformation stored in the physics engine to change because that will mess up a lot of stuff when you perform actual physical simulation. So if you want to force the transformation in the physics engine to change based on the marker transform, you need to manually do it through SetTransform method (specific to NetwonPhysics)</p>\r\n<p>Ohan</p>",
    "PostedDate": "2012-06-10T20:43:44.597-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "847831",
    "ThreadId": "359029",
    "Html": "<p>Hello eng_fron, few days ago I had the same problem that you, now i have a function that i think works well. I paste to you this function down. In my function I do more things that only picking, but maybe you can adapt it for your own proposes.</p>\r\n<p>Sorry for my bad english :(</p>\r\n<p>&nbsp;</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">static</span> <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">void</span> Pick(MouseEventArgs e)\r\n        {\r\n            Dictionary&lt;<span style=\"color: blue;\">int</span>, PickedObject&gt; findedList = <span style=\"color: blue;\">new</span> Dictionary&lt;<span style=\"color: blue;\">int</span>, PickedObject&gt;();\r\n\r\n\r\n            <span style=\"color: blue;\">if</span> (mouseDown)\r\n            {\r\n                mouseDown = <span style=\"color: blue;\">false</span>;\r\n\r\n                selectedVisualization.Box.Enabled = <span style=\"color: blue;\">false</span>;\r\n                selectedVisualization = <span style=\"color: blue;\">null</span>;\r\n\r\n\r\n                <span style=\"color: blue;\">foreach</span> (KeyValuePair&lt;<span style=\"color: blue;\">int</span>, GeometryNode&gt; pair <span style=\"color: blue;\">in</span> NodeRegister.planeNodes)\r\n                {\r\n                    pair.Value.Physics.Pickable = <span style=\"color: blue;\">false</span>;\r\n                    pair.Value.Enabled = <span style=\"color: blue;\">false</span>;\r\n                    pair.Value.AddToPhysicsEngine = <span style=\"color: blue;\">false</span>;\r\n                }\r\n\r\n\r\n\r\n                markerToTransform = -1;\r\n                <span style=\"color: blue;\">return</span>;\r\n            }\r\n\r\n            <span style=\"color: blue;\">if</span> (e.Button == MouseButtons.Left)\r\n            {\r\n                Vector3 nearSource = <span style=\"color: blue;\">new</span> Vector3(e.X, e.Y, 0);\r\n                Vector3 farSource = <span style=\"color: blue;\">new</span> Vector3(e.X, e.Y, 1);\r\n\r\n                <span style=\"color: green;\">// Debemos hacer una aproximaciï¿½n de los intervalos:</span>\r\n                nearSource.X = nearSource.X * 1024 / form.XnaPanel.Width; \r\n                nearSource.Y = nearSource.Y * 768 / form.XnaPanel.Height;\r\n\r\n\r\n                farSource.X = farSource.X * 1024 / form.XnaPanel.Width;\r\n                farSource.Y = farSource.Y * 768 / form.XnaPanel.Height;\r\n\r\n\r\n\r\n                <span style=\"color: green;\">// Debemos analizar cada marcador para comprobar el pick</span>\r\n                <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">int</span> i = 0; i &lt; 6; i++)\r\n                {\r\n                    <span style=\"color: green;\">// Primero comprobamos que hemos localizado el marcador y que tiene un modelo asociado</span>\r\n                    <span style=\"color: blue;\">if</span> (MarkerController.Markers[i].MarkerFound &amp;&amp; MarkerController.Markers[i].Children.Count &gt; 0)\r\n                    {\r\n                        <span style=\"color: green;\">// En caso de que se den las condiciones calculamos la viewMatrix para este marcador</span>\r\n                        Matrix viewMatrix = MarkerController.Markers[i].WorldTransformation * GoblinXNA.State.ViewMatrix;\r\n\r\n                        <span style=\"color: green;\">// Calculamos los puntos necesarios para el RayCasting</span>\r\n                        Vector3 nearPoint = sceneController.GraphicsDevice.Viewport.Unproject(nearSource, GoblinXNA.State.ProjectionMatrix, viewMatrix, Matrix.Identity);\r\n                        Vector3 farPoint = sceneController.GraphicsDevice.Viewport.Unproject(farSource, GoblinXNA.State.ProjectionMatrix, viewMatrix, Matrix.Identity);\r\n\r\n                        ((NewtonPhysics)sceneController.Scene.PhysicsEngine).RestartsSimulation();\r\n\r\n                        <span style=\"color: green;\">// Ahora calculamos el RayCasting y obtenemos los objetos interceptados</span>\r\n                        List&lt;PickedObject&gt; pickedObjects = ((NewtonPhysics)sceneController.Scene.PhysicsEngine).PickRayCast(nearPoint, farPoint);\r\n\r\n\r\n                        <span style=\"color: green;\">// Si hemos interceptado algï¿½n objeto</span>\r\n                        <span style=\"color: blue;\">if</span>(pickedObjects.Count &gt; 0)\r\n                        {\r\n                            <span style=\"color: green;\">// Ahora debemos mirar si en los picked se encuentra el modelo asociado al marker</span>\r\n                            List&lt;GeometryNode&gt; pickedNodes = <span style=\"color: blue;\">new</span> List&lt;GeometryNode&gt;();\r\n\r\n                            TransformNode associated = (TransformNode)MarkerController.Markers[i].Children[0];\r\n                            GeometryNode geometryAssociated = (GeometryNode)(associated.Children[0]);\r\n\r\n\r\n                            PickedObject nodeAssociated = <span style=\"color: blue;\">null</span>;\r\n\r\n                            <span style=\"color: blue;\">foreach</span> (PickedObject p <span style=\"color: blue;\">in</span> pickedObjects)\r\n                            {\r\n                                <span style=\"color: blue;\">string</span> a = ((GeometryNode)p.PickedPhysicsObject.Container).Name;\r\n                                <span style=\"color: blue;\">if</span> (geometryAssociated == ((GeometryNode)p.PickedPhysicsObject.Container))\r\n                                {\r\n                                    nodeAssociated = p;\r\n                                }\r\n                            }\r\n\r\n                            <span style=\"color: green;\">// Ahora ya sabemos si hemos picado en el objeto asociado al marcador, y si lo hemos hecho lo guardamos para poder comparar despuï¿½s</span>\r\n                            <span style=\"color: blue;\">if</span> (nodeAssociated != <span style=\"color: blue;\">null</span>)\r\n                                findedList.Add(i, nodeAssociated);\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                <span style=\"color: green;\">// Cuanto terminamos el bucle tenemos todos los pickedObject que hemos atravesado y que estï¿½n asociados con sus respectivos marcadores</span>\r\n                <span style=\"color: green;\">// Ahora debemos comparar cuï¿½l estï¿½ mas cerca</span>\r\n\r\n\r\n                <span style=\"color: blue;\">int</span> selectedMarker = -1;\r\n                <span style=\"color: blue;\">bool</span> firstFinded = <span style=\"color: blue;\">false</span>;\r\n\r\n\r\n                <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">int</span> i = 0; i &lt; 6; i++)\r\n                {\r\n                    <span style=\"color: blue;\">if</span> (findedList.ContainsKey(i))\r\n                    {\r\n                        <span style=\"color: blue;\">if</span> (!firstFinded)\r\n                        {\r\n                            selectedMarker = i;\r\n                            firstFinded = <span style=\"color: blue;\">true</span>;\r\n                        }\r\n                        <span style=\"color: blue;\">else</span> <span style=\"color: blue;\">if</span> (findedList[i].IntersectParam &lt; findedList[selectedMarker].IntersectParam)\r\n                        {\r\n                            selectedMarker = i;\r\n\r\n                            <span style=\"color: green;\">// Esto lo ponemos para que quede constancia del marcador, asï¿½ despuï¿½s podremos buscar el plano fï¿½cilmente</span>\r\n                            \r\n                        }\r\n                    }\r\n                }\r\n\r\n                markerToTransform = selectedMarker;\r\n\r\n                <span style=\"color: green;\">// Ahora ya sabemos cuï¿½l es el seleccionado, asï¿½ que marcamos la caja (si es que hay algï¿½n seleccionado)</span>\r\n\r\n                <span style=\"color: blue;\">if</span> (selectedMarker != -1)\r\n                {\r\n                    TransformNode t = (TransformNode)MarkerController.Markers[selectedMarker].Children[0];\r\n                    GeometryNode g = (GeometryNode)t.Children[0];\r\n\r\n                    <span style=\"color: green;\">// Obtenemos la visualizaciï¿½n asociada</span>\r\n\r\n                    Visualization v = NodeRegister.GetVisualization(g);\r\n\r\n                    <span style=\"color: blue;\">if</span> (selectedVisualization != <span style=\"color: blue;\">null</span>)\r\n                        selectedVisualization.Box.Enabled = <span style=\"color: blue;\">false</span>;\r\n\r\n                    v.Box.Enabled = <span style=\"color: blue;\">true</span>;\r\n\r\n                    selectedVisualization = v;\r\n\r\n\r\n                    <span style=\"color: green;\">// Ademï¿½s vamos a hacer que el ï¿½nico plano pickable sea el del objeto seleccionado, de esta forma no puede haber fallos</span>\r\n                    <span style=\"color: green;\">// al encontrar mï¿½s de un plano </span>\r\n\r\n                    <span style=\"color: green;\">// Hacemos que todos los planos dejen de ser pickables</span>\r\n                    <span style=\"color: blue;\">foreach</span> (KeyValuePair&lt;<span style=\"color: blue;\">int</span>, GeometryNode&gt; pair <span style=\"color: blue;\">in</span> NodeRegister.planeNodes)\r\n                    {\r\n                        pair.Value.Physics.Pickable = <span style=\"color: blue;\">false</span>;\r\n                        pair.Value.Enabled = <span style=\"color: blue;\">false</span>;\r\n                        pair.Value.AddToPhysicsEngine = <span style=\"color: blue;\">false</span>;\r\n                    }\r\n\r\n\r\n                    <span style=\"color: green;\">// Ahora hacemos pickable el del marker seleccionado</span>\r\n                    NodeRegister.planeNodes[selectedMarker].Physics.Pickable = <span style=\"color: blue;\">true</span>;\r\n                    NodeRegister.planeNodes[selectedMarker].Enabled = <span style=\"color: blue;\">true</span>;\r\n                    NodeRegister.planeNodes[selectedMarker].AddToPhysicsEngine = <span style=\"color: blue;\">true</span>;\r\n\r\n                }\r\n                <span style=\"color: blue;\">else</span>\r\n                {\r\n                    <span style=\"color: blue;\">if</span> (selectedVisualization != <span style=\"color: blue;\">null</span>)\r\n                    {\r\n                        selectedVisualization.Box.Enabled = <span style=\"color: blue;\">false</span>;\r\n                        selectedVisualization = <span style=\"color: blue;\">null</span>;\r\n\r\n                        markerToTransform = -1;\r\n\r\n                        <span style=\"color: green;\">// Ademï¿½s hacemos que ningï¿½n plano pueda ser pickable</span>\r\n\r\n                        <span style=\"color: blue;\">foreach</span> (KeyValuePair&lt;<span style=\"color: blue;\">int</span>, GeometryNode&gt; pair <span style=\"color: blue;\">in</span> NodeRegister.planeNodes)\r\n                        {\r\n                            pair.Value.Physics.Pickable = <span style=\"color: blue;\">false</span>;\r\n                            pair.Value.Enabled = <span style=\"color: blue;\">false</span>;\r\n                            pair.Value.AddToPhysicsEngine = <span style=\"color: blue;\">false</span>;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2012-06-12T02:28:30.453-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "848024",
    "ThreadId": "359029",
    "Html": "<p>Sorry, I tested again my function and dosnt work all the times :(</p>",
    "PostedDate": "2012-06-12T09:04:44.217-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "848050",
    "ThreadId": "359029",
    "Html": "\r\n<p>Thank you for the code and the insight eagle17 :)</p>\r\n<p>I've read the code and still trying to understand it,</p>\r\n<p>would you mind to explain why did you put this code when you are trying to find the ray picked marker</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>findedList[i].IntersectParam &lt; findedList[selectedMarker].IntersectParam\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Is this code trying to find the object that is ray picked and intersected closest to the window?</p>\r\n<p>and still don't understand what this code is actually do before you ray pick</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre> ((NewtonPhysics)sceneController.Scene.PhysicsEngine).RestartsSimulation();</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>currently I can't open the API documentation .chm for some reason so I cant find the meaning of .RestartsSimulations()</p>\r\n<p>this workaround might work with my requirement too although it still need to be adapted and it doesn't modify any transformation in the physics engine except the deactivation and activation of physics, I haven't tested on my app though</p>\r\n<p>Could you tell me the detail of &quot;doesn't work all the times&quot; as you have said?</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks :)</p>\r\n",
    "PostedDate": "2012-06-12T10:11:17.407-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "848077",
    "ThreadId": "359029",
    "Html": "<p>Hello eng_front! Now I'm trying a new thing that maybe works. First, I only use one model for one marker, I don't know if this is your case...</p>\r\n<p>&nbsp;</p>\r\n<p>Ok, I put the Propertie AddToPhysicsEngine of all of the GeometryNodes to false.&nbsp;</p>\r\n<p>When I'm doing the Picking, do this:</p>\r\n<p>\r\n<hr />\r\n</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre> geometryAssociated.AddToPhysicsEngine = <span style=\"color: blue;\">true</span>;\r\n\r\n\r\n\r\n\r\nMatrix viewMatrix = MarkerController.Markers[i].WorldTransformation * GoblinXNA.State.ViewMatrix;\r\n\r\n<span style=\"color: green;\">// Calculamos los puntos necesarios para el RayCasting</span>\r\nVector3 nearPoint = sceneController.GraphicsDevice.Viewport.Unproject(nearSource, GoblinXNA.State.ProjectionMatrix, viewMatrix, Matrix.Identity);\r\nVector3 farPoint = sceneController.GraphicsDevice.Viewport.Unproject(farSource, GoblinXNA.State.ProjectionMatrix, viewMatrix, Matrix.Identity);\r\n\r\nsceneController.Scene.Draw(<span style=\"color: blue;\">new</span> System.TimeSpan(), <span style=\"color: blue;\">false</span>);\r\n\r\n                       \r\n\r\n<span style=\"color: green;\">// Ahora calculamos el RayCasting y obtenemos los objetos interceptados</span>\r\nList&lt;PickedObject&gt; pickedObjects = ((NewtonPhysics)sceneController.Scene.PhysicsEngine).PickRayCast(nearPoint, farPoint);\r\n\r\n                        \r\ngeometryAssociated.AddToPhysicsEngine = <span style=\"color: blue;\">false</span>;\r\n</pre>\r\n</div>\r\n</p>\r\n<p>\r\n<hr />\r\n</p>\r\n<p>What I'm doing is put the geometry Node property AddToPhysicsEngine to True, then I draw the scene (because drawing the scene, I'm updating the physics engine). Now I can do the RayCast with only the GeometryNode that I want presents in the physics engine.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-06-12T10:51:28.517-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]