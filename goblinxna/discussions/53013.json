[
  {
    "Id": "178263",
    "ThreadId": "53013",
    "Html": "Hi there! First of all, I'd just like to say Goblin XNA Rocks!<br><br><div><span style=\"font-style:italic\">Please accept my appologies if you've received about 1 billion emails regarding this post!  I've been tweeking and adding to it all evening and it suddenly dawned on me that you may be receiving an email notification for every update!  If this is the case, please let me know and I'll be more careful in future!</span></div><div><br><div>I would be very grateful if you could help me with my query regarding animated (skinned) models and Goblin XNA.  The verbose post below details all my endeavours, successes and failures, however this is all based on the integration of the Skinned Model sample from the XNA Creators Club and the Goblin XNA framework.  So if there's a simpler way to do animation with Goblin XNA then you needn't read on any further ;) But I would be very interested in hearing how this is done :)</div><div><br></div><div><span style=\"text-decoration:underline\">Overview</span><span style=\"font-style:italic\"> </span></div><div><br></div><div>I am having some trouble adding an animated character to my game.  Being new to XNA (and 3D game development in general!) I went straight for the Skinned Model sample, from the XNA Creators Club.  Once I got my head around the code, I set about integrating it into my Goblin XNA game.  I've been able to successfully render an animated character* however the shadow effects are incorrect.  The interaction with occluder objects seems to behave correctly.  The problem I believe is that the shadow effect is bound to the none animated model (which is not drawn because I override the  base model object's Render() method).<br><br></div><div><span style=\"font-style:italic\">* The 'tiny_4anim.x' model from the Microsoft DirectX SDK (March 2009) download.</span></div><div><br><span style=\"text-decoration:underline\">Background to the 'Skinned Model sample' (</span><span style=\"text-decoration:underline\">XNA Creators Club)</span><br><br>The Skinned Model sample implements a custom Content Processor called 'SkinnedModelProcessor'.  My .x model file is configured to use this processor instead of the default processor 'Model - XNA Framework'.  The custom content processor uses a custom effect called 'SkinnedModel'.  This effect does not have a 'World' parameter like the default 'BasicEffect' effect.  Instead it has a 'Bones' parameter (an array of Matrix objects which represent the Skin Transforms generated from the animation player object).  The game's Update method calls the AnimationPlayer's Update method, passing in the model's 'World' transform.  The animation player then generates the next set of Skin Transforms to be used by the custom 'SkinnedModel' effect.<br><br><span style=\"text-decoration:underline\">How I've integrated the Skinned Model code with my GoblinXNA game<br><br></span>I have sub-classed 'GoblinXNA.Graphics.Model' and 'GoblinXNA.Graphics.ModelLoader', creating a 'SkinnedModel' class and a 'SkinnedModelLoader' class.  The 'SkinnedModel' class has two additional properties and overrides the Render() method.  The two additional properties are as follows:-<div><br></div><div>1. Matrix[] SkinTransforms  -  An array of Matrix objects to represent the skin transforms (generated by an AnimationPlayer object).<br>2. SkinningData SkinningData  -  Combines all the data needed to render and animate a skinned object.  Obtained via the inner Model's Tag property.<br><br></div><div><span style=\"font-style:italic\">See the bottom of this post for the class code.</span></div><div><br></div><div>The overridden Render() method uses the new 'SkinTransforms' property to set the custom 'Bones' parameter on the custom 'SkinnedModel.fx' effect.<br></div><div><div> <br>The 'SkinnedModelLoader' class overrides the Load() method to create and return a new 'SkinnedModel' object (with a Tag property containing the SkinningData).  <span style=\"font-style:italic\">See the bottom of this post for the class code.</span>  <br><br>This solution actually works, however there is at least one issue that I am aware of, which is explained below.<br><br><span style=\"text-decoration:underline\">Problem Definition<br></span><br>The shadow effects are still bound to the basic effect therefore the shadows are drawn incorrectly.  Put another way, if I add a call to the base render method within the overridden Render() method, then the shadows follow the model being rendered by the basic effect.  My current work-around is to set the 'CastShadows' property to <span style=\"font-style:italic\">false</span> (on my skinned model's 'Geometry' node).<br><br>Am I on the right track here or am I going completely against the Goblin XNA framework?  I know that the default GoblinXNA.Graphics.Model object has two interesting properties: namely AnimatedMeshes and AnimationTransforms, however I don't know how to use them.<br><br>Do I just need to implement my own shadow effect?<br><br>Any advice would be greatly appreciated!<br><br>Regards<br>Simon<br><br>CODE SNIPPETS</div><div><br></div><div>1) SkinnedModel.cs</div><div>2) SkinnedModelLoader.cs</div><div>3) AnimationPlayer.cs</div><div>4a) Game.cs - CreateObjects()</div><div>4b) Game.cs - Update()<br></div><div><br></div><div><div>/********************************************************************************/</div><div>/* 1) SkinnedModel.cs                                                                                                                            */</div><div>/********************************************************************************/<br></div><div>namespace GoblinXNAExtensions.Graphics</div><div>{</div><div>    public class SkinnedModel : GoblinXNA.Graphics.Model</div><div>    {</div><div>        private SkinningData _skinningData;</div><div>        private Matrix[] _skinTransforms;</div><div><br></div><div>        public SkinnedModel(Matrix[] transforms, ModelMeshCollection meshes, SkinningData skinningData)</div><div>            : base(transforms, meshes, null, null)</div><div>        {</div><div>            _skinningData = skinningData;</div><div>        }</div><div><br></div><div>        public SkinningData SkinningData</div><div>        {</div><div>            get</div><div>            {</div><div>                return _skinningData;</div><div>            }</div><div>        }</div><div><br></div><div>        public Matrix[] SkinTransforms</div><div>        {</div><div>            get</div><div>            {</div><div>                return _skinTransforms;</div><div>            }</div><div>        }</div><div><br></div><div>        /// &lt;summary&gt;</div><div>        /// Method to allow a caller to update the skin transformations.</div><div>        /// &lt;/summary&gt;</div><div>        /// &lt;rremarksThis method is used as the event handler for the AnimationPlayer event SkinTransformsUpdated.&lt;/remarks&gt;</div><div>        /// &lt;param name=&quot;skinTransforms&quot;&gt;&lt;/pparam</div><div>        public void UpdateSkinTransforms(Matrix[] skinTransforms)</div><div>        {</div><div>            _skinTransforms = skinTransforms;</div><div>        }</div><div><br></div><div>        public override void UpdateAnimationTransforms(Matrix[] animationTransforms)</div><div>        {</div><div>            throw new NotImplementedException();</div><div>        }</div><div><br></div><div>        public override void Render(Matrix renderMatrix, Material material)</div><div>        {</div><div>            //base.Render(renderMatrix, material);</div><div><br></div><div>            GraphicsDevice device = State.Device;</div><div><br></div><div>            // Render the skinned mesh.</div><div>            foreach (ModelMesh mesh in this.Mesh)</div><div>            {</div><div>                foreach (Effect effect in mesh.Effects)</div><div>                {</div><div>                    effect.Parameters[&quot;Bones&quot;].SetValue(_skinTransforms);</div><div>                    effect.Parameters[&quot;View&quot;].SetValue(State.ViewMatrix);</div><div>                    effect.Parameters[&quot;Projection&quot;].SetValue(State.ProjectionMatrix);</div><div>                }</div><div>                mesh.Draw();</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div><br></div><div><div>/********************************************************************************/</div><div>/* 2) SkinnedModelLoader.cs                                                                                                                 */</div><div>/********************************************************************************/</div></div><div><div>namespace GoblinXNAExtensions.Graphics<br></div><div>{</div><div>    public class SkinnedModelLoader : IModelLoader</div><div>    {</div><div>        public IModel Load(String path, String modelAssetName)</div><div>        {</div><div>            SkinnedModel skinnedModel = null;</div><div>            path = (path.Equals(&quot;&quot;)) ? State.GetSettingVariable(&quot;ModelDirectory&quot;) : path;</div><div>            String filePath = Path.Combine(path, modelAssetName);</div><div>            XNAModel xnaModel = State.Content.Load&lt;XXNAModel(@&quot;&quot; + filePath);</div><div><br></div><div>            // Get matrix transformations of the model</div><div>            if (xnaModel != null)</div><div>            {</div><div>                Matrix[] transforms = new Matrix[xnaModel.Bones.Count];</div><div>                xnaModel.CopyAbsoluteBoneTransformsTo(transforms);</div><div><br></div><div>                bool preConditionPassed = false;<br></div><div>                if (xnaModel.Tag == null)</div><div>                {</div><div>                    preConditionPassed = false;</div><div>                }</div><div>                else if (xnaModel.Tag is SkinningData == false)</div><div>                {</div><div>                    preConditionPassed = false;</div><div>                }</div><div>                else</div><div>                {</div><div>                    preConditionPassed = true;</div><div>                }</div><div><br></div><div>                if (!preConditionPassed)</div><div>                {</div><div>                    throw new InvalidOperationException(&quot;This model does not contain a SkinningData tag.&quot;);</div><div>                }</div><div>                 <br></div><div>                skinnedModel = new SkinnedModel(transforms, xnaModel.Meshes, xnaModel.Tag as SkinningData);</div><div>            }</div><div>            else</div><div>            {</div><div>                Log.Write(&quot;Model &quot; + filePath + &quot; does not exist &quot;);</div><div>            }</div><div><br></div><div>            return skinnedModel;</div><div>        }</div><div>    }</div><div>}</div><div><br></div></div><div><div><div>/********************************************************************************/</div><div>/* 3) AnimationPlayer.cs                                                                                                                          */</div><div>/*                                                                                                                                                            */<br></div><div>*  Please note: The model object is subscribed to the SkinTransformsUpdated event.  The event is fired    */ </div><div>/* at the end of the UpdateSkinTransforms() method.                                                                               */<br></div><div>/********************************************************************************/</div></div><div></div><div>namespace GoblinXNAExtensions.Graphics<br></div><div>{</div><div>    public delegate void SkinTransformsUpdated(Matrix[] skinTransforms);</div><div><br></div><div>    /// &lt;summary&gt;</div><div>    /// The animation player is in charge of decoding bone position</div><div>    /// matrices from an animation clip.</div><div>    /// &lt;/summary&gt;</div><div>    public class AnimationPlayer</div><div>    {</div><div>        #region Fields</div><div><br></div><div>        private SkinTransformsUpdated _skinTransformsUpdatedDelegate;</div><div><br></div><div>        public event SkinTransformsUpdated SkinTransformsUpdated</div><div>        {</div><div>            add { _skinTransformsUpdatedDelegate += value; }</div><div>            remove { _skinTransformsUpdatedDelegate -= value; }</div><div>        }</div><div><br></div><div>        // Information about the currently playing animation clip.</div><div>        private AnimationClip _currentClipValue;</div><div>        private TimeSpan _currentTimeValue;</div><div>        private int _currentKeyframe;</div><div>        </div><div>        // Current animation transform matrices.</div><div>        private Matrix[] _boneTransforms;</div><div>        private Matrix[] _worldTransforms;</div><div>        private Matrix[] _skinTransforms;</div><div><br></div><div>        // Backlink to the bind pose and skeleton hierarchy data.</div><div>        private SkinningData _skinningDataValue;</div><div><br></div><div>        #endregion</div><div>        </div><div>        /// &lt;summary&gt;</div><div>        /// Constructs a new animation player.</div><div>        /// &lt;/summary&gt;</div><div>        public AnimationPlayer(SkinnedModel model)</div><div>        {</div><div>            if (model.SkinningData == null)</div><div>            {</div><div>                throw new ArgumentNullException(&quot;skinningData&quot;);</div><div>            }</div><div><br></div><div>            _skinningDataValue = model.SkinningData;</div><div>            _boneTransforms = new Matrix[model.SkinningData.BindPose.Count];</div><div>            _worldTransforms = new Matrix[model.SkinningData.BindPose.Count];</div><div>            _skinTransforms = new Matrix[model.SkinningData.BindPose.Count];</div><div><br></div><div>            SkinTransformsUpdated += new SkinTransformsUpdated(model.UpdateSkinTransforms);</div><div>        }</div><div><br></div><div>        #region properties</div><div><br></div><div>        /// &lt;summary&gt;</div><div>        /// Gets the current bone transform matrices, relative to their parent bones.</div><div>        /// &lt;/summary&gt;</div><div>        public Matrix[] GetBoneTransforms()</div><div>        {</div><div>            return _boneTransforms;</div><div>        }</div><div>        </div><div>        /// &lt;summary&gt;</div><div>        /// Gets the current bone transform matrices, in absolute format.</div><div>        /// &lt;/summary&gt;</div><div>        public Matrix[] GetWorldTransforms()</div><div>        {</div><div>            return _worldTransforms;</div><div>        }</div><div>        </div><div>        /// &lt;summary&gt;</div><div>        /// Gets the current bone transform matrices,</div><div>        /// relative to the skinning bind pose.</div><div>        /// &lt;/summary&gt;</div><div>        public Matrix[] GetSkinTransforms()</div><div>        {</div><div>            return _skinTransforms;</div><div>        }</div><div>        </div><div>        /// &lt;summary&gt;</div><div>        /// Gets the clip currently being decoded.</div><div>        /// &lt;/summary&gt;</div><div>        public AnimationClip CurrentClip</div><div>        {</div><div>            get { return _currentClipValue; }</div><div>        }</div><div><br></div><div>        /// &lt;summary&gt;</div><div>        /// Gets the current play position.</div><div>        /// &lt;/summary&gt;</div><div>        public TimeSpan CurrentTime</div><div>        {</div><div>            get { return _currentTimeValue; }</div><div>        }</div><div><br></div><div>        #endregion</div><div><br></div><div>        #region public methods</div><div><br></div><div>        /// &lt;summary&gt;</div><div>        /// Starts decoding the specified animation clip.</div><div>        /// &lt;/summary&gt;</div><div>        public void StartClip(AnimationClip clip)</div><div>        {</div><div>            if (clip == null)</div><div>            {</div><div>                throw new ArgumentNullException(&quot;clip&quot;);</div><div>            }</div><div><br></div><div>            _currentClipValue = clip;</div><div>            _currentTimeValue = TimeSpan.Zero;</div><div>            _currentKeyframe = 0;</div><div><br></div><div>            // Initialize bone transforms to the bind pose.</div><div>            _skinningDataValue.BindPose.CopyTo(_boneTransforms, 0);</div><div>        }</div><div><br></div><div>        /// &lt;summary&gt;</div><div>        /// Advances the current animation position.</div><div>        /// &lt;/summary&gt;</div><div>        public void Update(TimeSpan time, bool relativeToCurrentTime, Matrix rootTransform)</div><div>        {</div><div>            UpdateBoneTransforms(time, relativeToCurrentTime);</div><div>            UpdateWorldTransforms(rootTransform);</div><div>            UpdateSkinTransforms();</div><div>        }</div><div><br></div><div>        /// &lt;summary&gt;</div><div>        /// Helper used by the Update method to refresh the BoneTransforms data.</div><div>        /// &lt;/summary&gt;</div><div>        public void UpdateBoneTransforms(TimeSpan time, bool relativeToCurrentTime)</div><div>        {</div><div>            // Update the animation position.</div><div>            if (relativeToCurrentTime)</div><div>            {</div><div>                time += _currentTimeValue;</div><div><br></div><div>                // If we reached the end, loop back to the start.</div><div>                while (time &gt;= _currentClipValue.Duration)</div><div>                    time -= _currentClipValue.Duration;</div><div>            }</div><div><br></div><div>            if ((time &lt; TimeSpan.Zero) || (time &gt;= _currentClipValue.Duration))</div><div>                throw new ArgumentOutOfRangeException(&quot;time&quot;);</div><div><br></div><div>            // If the position moved backwards, reset the keyframe index.</div><div>            if (time &lt; _currentTimeValue)</div><div>            {</div><div>                _currentKeyframe = 0;</div><div>                _skinningDataValue.BindPose.CopyTo(_boneTransforms, 0);</div><div>            }</div><div><br></div><div>            _currentTimeValue = time;</div><div><br></div><div>            // Read keyframe matrices.</div><div>            IList&lt;KKeyframe keyframes = _currentClipValue.Keyframes;</div><div><br></div><div>            while (_currentKeyframe &lt; keyframes.Count)</div><div>            {</div><div>                Keyframe keyframe = keyframes[_currentKeyframe];</div><div><br></div><div>                // Stop when we've read up to the current time position.</div><div>                if (keyframe.Time &gt; _currentTimeValue)</div><div>                {</div><div>                    break;</div><div>                }</div><div><br></div><div>                // Use this keyframe.</div><div>                _boneTransforms[keyframe.Bone] = keyframe.Transform;</div><div><br></div><div>                _currentKeyframe++;</div><div>            }</div><div>        }</div><div>        </div><div>        /// &lt;summary&gt;</div><div>        /// Helper used by the Update method to refresh the WorldTransforms data.</div><div>        /// &lt;/summary&gt;</div><div>        public void UpdateWorldTransforms(Matrix rootTransform)</div><div>        {</div><div>            // Root bone.</div><div>            _worldTransforms[0] = </div><div>                _boneTransforms[0] * </div><div>                rootTransform; </div><div>            </div><div>            // Child bones.</div><div>            for (int bone = 1; bone &lt; _worldTransforms.Length; bone++)</div><div>            {</div><div>                int parentBone = _skinningDataValue.SkeletonHierarchy[bone];</div><div>                _worldTransforms[bone] =  _boneTransforms[bone] * _worldTransforms[parentBone];</div><div>            }</div><div>        }</div><div>        </div><div>        /// &lt;summary&gt;</div><div>        /// Helper used by the Update method to refresh the SkinTransforms data.</div><div>        /// &lt;/summary&gt;</div><div>        public void UpdateSkinTransforms()</div><div>        {</div><div>            for (int bone = 0; bone &lt; _skinTransforms.Length; bone++)</div><div>            {</div><div>                _skinTransforms[bone] = </div><div>                    _skinningDataValue.InverseBindPose[bone] * _worldTransforms[bone];</div><div>            }</div><div><br></div><div>            // Raise update event</div><div>            if (_skinTransformsUpdatedDelegate != null)</div><div>            {</div><div>                _skinTransformsUpdatedDelegate(_skinTransforms);</div><div>            }</div><div>        }</div><div><br></div><div>        #endregion</div><div>    }</div><div>}</div><div><br></div><div>/********************************************************************************/</div><div>/* 4a) Game.cs                                                                                                                                        */</div><div>/*                                                                                                                                                            */<br></div><div>/*  Method CreateObjects() - not all the code is shown                                                                            */<br></div><div>/********************************************************************************/<br></div>private void CreateObjects()</div><div>{ </div><div>   ...</div><div><br></div><div>             // Create an animation player and start decoding an animation clip.</div><div>            _tinyAnimationPlayer = new AnimationPlayer(tinyModel);</div><div>            AnimationClip clip = tinyModel.SkinningData.AnimationClips[&quot;Loiter&quot;];</div><div>            _tinyAnimationPlayer.StartClip(clip);</div><div> </div><div>   ...</div><div><br></div><div>}</div><div><br></div><div><div><div>/********************************************************************************/</div><div>/* 4b) Game.cs                                                                                                                                        */</div><div>/*                                                                                                                                                            */<br></div><div>/*  Method Update()                                                                                                                               */<br></div><div>/********************************************************************************/<br></div><div> protected override void Update(GameTime gameTime)</div><div>{</div><div>     HandleInput();</div><div><br></div><div>     _tinyAnimationPlayer.Update(gameTime.ElapsedGameTime, true, _tinyTransformNode.WorldTransformation * _tinyNode.MarkerTransform);<br></div><div><br></div><div>     base.Update(gameTime);</div><div>}</div></div></div><div><br></div><div>END OF POST</div></div></div></div>",
    "PostedDate": "2009-04-11T16:38:06.343-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "178735",
    "ThreadId": "53013",
    "Html": "Hi Simon,<div><br></div><div>Nice work on very detailed descriptions^^. I don't set notifiers for new discussion post, so please feel free to modify as much as you need.</div><div><br></div><div>Thanks for bringing up the topic of animated models, and your approach of integrating the skinned model sample is correct (namely, extending the Model and ModelLoader classes). I actually incorporated the XNAnimation library (<a href=\"http://xnanimation.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=14889\">http://xnanimation.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=14889</a>) downloadable from codeplex to GoblinXNA almost a year ago, but I couldn't get the shadows to work correctly either since I couldn't get the transform for each of the model parts in the skinned model at that time. I didn't have time to work on the animation capability since then, and thus it's not included with the current Goblin XNA distribution. It seems like the XNAnimation library is improved, and probably I can get it to work correctly if I spend some time. </div><div><br></div><div>The shadow mapping in GoblinXNA is very robust, and not very extensible. You can implement your own shadow shader, but then you will need to also change many lines of code in Scene class. Once I incorporate the newer XNAnimation library, I hope I can make the shadow effect work correctly, but probably it won't happen until the next next release (v3.3).</div><div><br></div><div>AnimatedMeshes and AnimatedTransformations of the Model class is used to animate model parts of a static model (which is not a skinned model, and doesn't have any animation information in the model file). For example, if you want to animate the rotation of the <span style=\"font-family:'-webkit-sans-serif';font-size:13px;line-height:19px\">rotating blades</span> of a static windmill model, then you can assign the mesh of the <span style=\"font-family:'-webkit-sans-serif';font-size:13px;line-height:19px\">rotating blades</span> to AnimatedMeshes, and apply your rotation transformation to the AniamtedTransformation and manually rotate it.</div><div><br></div><div>Hope I answered all of your questions.</div><div><br></div><div>Ohan</div>",
    "PostedDate": "2009-04-13T17:56:52.68-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "178975",
    "ThreadId": "53013",
    "Html": "<p style=\"margin:0cm 0cm 0pt\">Hi Ohan,<br>\r\n<br>\r\nThanks for your response!  It's good to know that I was on the right track.<span>  </span>If the 'XNAnimation' integration piece is on the road map then I can happily forgo the shadow casting for now.  That said, I wouldn't mind having a go at attempting the integration myself.  Please feel free to encourage / discourage me as appropriate!  If the framework changes are quite deep-rooted then it might be better to leave this to someone who knows what they are doing ;)</p>\r\n<p style=\"margin:0cm 0cm 0pt\"> </p>\r\n<p style=\"margin:0cm 0cm 0pt\">Thanks also for explaining the usage of the 'AnimatedMeshes' and 'AnimationTransforms'.<span>  </span>I suspected these properties were for &quot;static&quot; models although I wasn't 100% sure.<br>\r\n<br>\r\nCheers</p>\r\n<p style=\"margin:0cm 0cm 0pt\">Simon</p>\r\n",
    "PostedDate": "2009-04-14T05:49:38.067-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "179821",
    "ThreadId": "53013",
    "Html": "Hi Simon,<div><br></div><div>I will probably release v3.2 in next few weeks, and there will be several modifications from v3.1. Since I can not guarantee to be able to include the animation stuff anytime soon, I would suggest that you incorporate XNAnimation with Goblin after the v3.2 release if animation is critical for your application. If the integration goes well, it'll be great if you could share the information with us.</div><div><br></div><div>Thanks</div><div>Ohan</div>",
    "PostedDate": "2009-04-15T13:42:30.267-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "179844",
    "ThreadId": "53013",
    "Html": "Hi Ohan,<br>\r\n<br>\r\nI'll hold off then until the release of v3.2.  In the meantime I'll familiarize myself with the latest version of XNAnimation.  I'll be happy to share my findings with you, assuming of course that I find any findings ;)<br>\r\n<br>\r\nCheers<br>\r\nSimon<br>\r\n",
    "PostedDate": "2009-04-15T15:25:48.223-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "287356",
    "ThreadId": "53013",
    "Html": "<p>HI Simon,</p>\r\n<p>Thanks for such an informative post.</p>\r\n<p>How have u incorporated modelanimator class in order to load an animated unskinned model?</p>\r\n<p>Looking forward to your reply!</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-02-08T16:23:09.29-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]